    # Minor breakpoints
- Fine tune font size, spacing, etc. at minor breakpoints even if the layout isn't changing.


# Fonts
- Ideal Measure (the length of a line of text)
    - 45 - 90 characters per line (cpl)
    -  *Try 65 cpl*
    -  Use measure as a factor for choosing breakpoints

- Size
    - Minimum font size: 16px
    - Minimum line-height: 1.2em
    - Consider increasing both for text heavy sites


# Writing READMEs
- Good questions to ask yourself:
    - What steps need to be taken?
    - What should the user already have installed or configured?
    - What might they have a hard time understanding right away?
- Chooseing a license
    - https://choosealicense.com/
- Online Markdown editor with a live view
    - https://dillinger.io/  

#Contained Table
- Wrap the table in a div (ex. `<div class="contained_table">table goes here</div>)
` 
div.contained_table {
    width: 100%;
    overflow-x: auto;
}
`

# Project 1 Notes - Portfolio
- Image resources
    - [yellow pencils](https://unsplash.com/photos/1_CMoFsPfso)
        - Use art direction
- Use yellow images (search "yellow" on unsplash.com) for app backgrounds
    - [pixel "app"](https://unsplash.com/photos/WEVSu0CB2M4)
    - [neighborhood "app"](https://unsplash.com/photos/np9Tr3SDRw4)
    - [memory "app"](https://unsplash.com/photos/bmS3th_-BIg)
- Fonts
    - [Raleway](https://fonts.google.com/specimen/Raleway)
        - Has a really cool "W"
    - [Lato](https://fonts.google.com/specimen/Lato)
        - Pretty classic


# Javascript syntax
- Variables
    - `let` if value will change
    - `const` if value will be static
    - If unsure, use `const` and change to `let` later if need be.
- Template literals
    - Denoted with backticks `` and contain placeholders ${expression}.
        - Kind of like powershell...
    - Work well with multi-line strings since implicit newlines are part of the string.
    - Within expressions, can also perform operations, call functions, and use loops!
- Destructuring
    - Destructuring borrows inspiration from languages like Perl and Python by allowing 
    you to specify the elements you want to extract from an array or object on the left 
    side of an assignment. 


# Command line
- Useful commands
    - ls 
        - can use * as awildcard for searching
    - pwd
    - curl
        - Use `-L` to follow redirects
        - Use `-o` plus filename to output results to a file
    - grep
- Single quotes mean treat any special characters as just a normal character (e.g. !, *, &, etc)    


# Git
- Three main areas:
    - Working  Directory
    - Staging Index
    - Repository
- Setting up Git: 
    # sets up Git with your name
    git config --global user.name "<Your-Full-Name>"

    # sets up Git with your email
    git config --global user.email "<your-email-address>"

    # makes sure that Git output is colored
    git config --global color.ui auto

    # displays the original state in a conflict
    git config --global merge.conflictstyle diff3

    git config --list

# Bash profile stuff to make git easier to navigate (save to `.bash_profile`)
- 
        # Enable tab completion
        source ~/.udacity-terminal-config/git-completion.bash

        # Change command prompt
        source ~/.udacity-terminal-config/git-prompt.sh

        # colors!
        red="\[\033[38;5;203m\]"
        green="\[\033[38;05;38m\]"
        blue="\[\033[0;34m\]"
        reset="\[\033[0m\]"

        export GIT_PS1_SHOWDIRTYSTATE=1

        # '\u' adds the name of the current user to the prompt
        # '\$(__git_ps1)' adds git-related stuff
        # '\W' adds the name of the current directory
        export PS1="$red\u$green\$(__git_ps1)$blue \W
        $ $reset"

# Version Control / Git
- Commands
    - `git init`
        - Creates a new empty respository in the current directory
    - `git clone`
        - Clones an existing repository
        - `git clone <path-to-repository-to-clone>`
    - `git status
        - Use this a lot!
    - `git log`
        - Displays information about the existing commits
        - `git log --oneline` -shows compressed view
        - `git log --stat` -aka statistics. Shows detailed view.
        - `git log --patch` - aka --p shows the actual changes to a file.
        - `git log --oneline --graph --all` shows all branches visually
        - `git log --grep 'search string" searches commits for string
    - `git show`
        - Displays information about the given commit (you supply which commit)
        - Can use many of the same commands as git log.
    - `git add`
        - add files to staging index.
        - `git add <filename1> <filename2>` to add one file (or multiple named files) 
        - `git add .` to add everything in current directory (and all subdirectories)
    - `git commit` 
        - commits staged files. Opens up text editor to write commit message first.
        - `git commit -m "Commit message here"` bypasses the open the editor stage
        - Finish the sentence "This commit will ..."
        - `git commit --amend`
            - if working directory is clean, will let you update commit message
            - if there are staged files, will let you add them to previous commit
    - `git diff`
        - See changes that have been made but haven't been committed yet.
    - `.gitignore`
        - Not a command but a file in the same directory level as the .git folder
        - Files listed in .gitignore are ignored by git.
        - Can also use "globbing" for wildcard matching
    - `git tag`
        - Adds a tag to particular commit
        - `git tag -a "tag name"` adds a tag. The -a part means it is annotated
        the person who made the tag, the date, and a message for the tag.
        - `git tag` by itself will list all the tags in the respository.
        - `git tag -d "tag name" the -d will delete the specified tag.
        - `git tag -a "tag name" <SHA>` will let you add a tag to any specified commit.
    - `git branch`
        - list all branch names and specified the active branch
        - `git branch "branch_name"` creates new branch
        - `git branch "branch_name SHA" creates new branch from specified commit
        - `git branch -d "named_branch"` deletes the named branch
            - Note: can't delete a branch you are currently in
    - `git checkout`
        - `git checkout "branch_name" this will move to the named branch AND
            - Remove all files and directories from the Working Directory that Git is tracking
            - Go into the repository and pull out all of the files and directories of the 
            branch
        - Changes where the HEAD pointer is referencing
        - `git checkout -b "new_branch_name"` makes a new branch and switch to it
    - `git merge` 
        - merges branches. Make sure you are in the branch you want to continue
        - `git merge <name-of-branch-to-merge-in> does the merge. Git to will:
            - look at the branches that it's going to merge
            - look back along the branch's history to find a single shared commit
            - merge the code
            - make a commit to record the merge
        - `git reset --hard HEAD^` undo merge (include caret character!) 
        - merge conflicts - make sure you clean up teh merge conflict characters 
        before committing!
            - search file for `<<<` to locate all of the conflicts 
    - `git revert` 
        - takes changes that were made in a commit and undoes them
        - `git revert <SHA-of-commit-to-revert>` - undoes specified commit, creates new 
        commit to record the change
    - `git reset` 
        - Erases commits. ERASES! Reverting creates a new commit that undoes previous commit.
        Information is stil there with the `git revert` command
            - `git reflog` can recover `git reset` deletions within 30 days
            - flags
                `--mixed` default. Removed changes written back to files in staging directory.
                `--soft` moves removed changes to the staging index.
                `--hard` moves removed changes to trash.
    - Relative commit references
        - `^` indicates the parent commit
        - `~` indicates teh first parent commit
        - can stack. Aka `^^` is the grandparent of the commit
        - merge commits have two parents. First parent is the branch you were on when 
        `git merge` was run. Second parent is branch that was merged in.
            - with a merge commit `^` is used to indicate the first parent and 
            `^2` is the second parent.
            - `HEAD^^^2` is the grandparent's (HEAD^^) second parent(^2)
            - `HEAD~3` - the "~3" means 3 commits before the HEAD pointer.


# Git / Remote Repository
- Commands
    - `git remote`
        - `git remote add origin <repo-on-github>`
            - 'origin' is just a convention - could call it anything
            - adds a remote repository
        - `git remote -v` shows full location of remote repository
        - `git remote rename <remote_site_old_name> <remote_site_new_name>
    - `git push`
        - send local commits to a remote repository
        - `git push <remote-shortname> <branch>`
        - New marker on git log (e.g. `origin/master`) is the tracking branch. Says that the 
        remote 'origin' has a 'master' branch that points to the specified commit
    - `git pull`
        - Pull remote repository (aka fetch remote commits and merge them into local repo)
        - `git pull <remote-shortname> <branch>
    - `git fetch`
        - retrieves commits from a remote repository but it does not automatically 
        merge them. The "origin/master" pointer moves but the "master" pointer does not.


# Working on Another Developer's Repository
- Forking a repository
    - There is no `git fork` command. Part of the hosting environment.
    - Makes an identical copy of their repository that belongs to you.
    - Once forked, can then `git clone`
- Commands
    - `git shortlog`
        - Shows how many alphabetical list of names and their commit messages.
        - `git shortlog -s -n`
            - Shows the number of commits by each developer.
            - `-s` show just the number of commits
            - `-n` sort results numerically
    - `git log --author="author name"`
        - filter commits to the specified author
- What to work on
    - Check the CONTRIBUTING.md file of their project
    - Check the Issues page of their project
- Develop all of your work on a single topic branch
    - Give the topic branch a clear name
- General best practices for writing commits:
    - makre frequest, smaller commits
    - use clear and descriptive commit messages
    - update the README file if necessary


# Staying in Sync With a Remote Repository
- How to create a pull request
    - Fork the soruce respository
    - Clone fork on local machine
    - Make some commits (ideally on a topic branch)
        - See section "Working on Another Developer's Repository"
    - Push the commits back to your fork
    - Create a new pull request and choose the branch that has your new commits
- Stay in sync with the source project
    - "Starring" a respository - like adding it to a favorites's list but no notifications
    - "Watching" a respository - get notified of changes
    - To include upstream changes
        - `git remote add upstream <url_of_original>
            - adds another remote site
            - "upstream" is the conventional name
        - `git fetch <remote_site> <branch>`
        - Merge the upstream's branch into local branch (verify you are in the correct branch)
        - Push the newly update branch to your origin repo
- Manage an Active PR
    - If the project's maintainer is requesting changes to the pull request:
        - Make any necessary commits on the same branch on your local repository
        - Push the branch to _your_ fork fo the source repository
    - `git rebase`
        - will squash commits (consolidate commits on a new base)
        - `git rebase -i HEAD~3` and replace "3" with the number of commits you want to 
        squash.
            - Will then open editor where you need to say what you want to do to each commit.
            - Oldest commit will be at top.
            - Need to keep (aka pick) at least one commit but can also change the commit 
            message (reword) to reflect the squash
            - Will likely need to do a git push force since GitHub will be unhappy that you
            are trying to push a branch with fewer commits.
        - Be careful with `git rebase`! Rebasing will create a new commit with a new SHA which
        has the potential to severely mess up anyone else who might be working with commits 
        you've already pushed. They may not be able to get their repo back in sync and might 
        have to start over.


# Document Object Model
- Model of the relationships and attributes of the of the HTML document.
- NOT part of the JavaScript languages
    - Constructed by the browser
    - Is globally accesible by JS using the `document` object
- Select page element by ID
    - `document.getElementbyID('id_here');`
        - Don't need to include the `#` prefix
        - Only returns on element
- Select page elements by class or tag
    - `document.getElementsByClass('class_here');`
    - `document.getElementsByTagName('tag_name_here');`
    - The returned elements are not an array but an HTML collection.
- Nodes, Elements, and Interfaces
    - Nodes & nodes
        - Capital N Nodes - like a class
        - lower case n nodes - like an object
    - Interface
        - List of properties and methods that are inherited
        - Properties = data
        - Methods = functionality
    - Element Interface is a descendent of the Node Interface
        - Therefore inherits all of Node's properties and methods
    - Note: In Chrome web inspector, `$0` refers to the highlighted element in the "Elements"
    tab
    - To check out all the different interfaces of different elements:
    https://developer.mozilla.org/en-US/docs/Web/API
- More Wayys to Access Elements
    - `document.querySelector('css_selector_here')
        - NOTE: Only returns 1 elements. In cases of multiple elements that match, it will
        only return the first item it finds.
    - `document.querySelectorAll('css_selector_here')
        - Will return multiple elements


# Creating Content with Javascript
- Updating existing page content
    - `.innerHTML' 
        - gets/sets the HTML content _inside_ the selected element.
        Includes HTML tags.
        - When setting `.innterHTML` - HTML code is parsed as HTML
    - `.textContent` 
        - gets/sets the text content of an element and all its descendants
        - Returns all text available
        - `innerText` gets the visual text as it would be seen visually
- Add new page content
    - `document.createElement('tag_name')`
        - Just creates. Doesn't place on page.
    - `.appendChild(newly_created_element)`
        - `.appendChild()` will add it as the last child
        - if an element already exists on the DOM, `.appendChild(foo)`will move it instead 
        of duplicating it.
    - `.insertAdjacentHTML('location', HTMLtext)`
        - Requires 2 arguments: (1) location of HTML (2) HTML text to be inserted
            - beforebegin – inserts the HTML text as a previous sibling 
            - afterbegin – inserts the HTML text as the first child 
            - beforeend – inserts the HTML text as the last child 
            - afterend – inserts the HTML text as a following sibling

            A visual example works best, and MDN's documentation has a fantastic example that I'll modify slightly:

            <!-- beforebegin -->
            <p>
                <!-- afterbegin -->
                Existing text/HTML content
                <!-- beforeend -->
            </p>
            <!-- afterend -->
    - `.textcontent` property is used more than creating a text node `.createTextNode()`
- Remove page content
    - `<parent_element>.removeChild(<child_to_remove>)`
        - Instead of looking up parent element - can call it directly using the 
        `.parentElement` property. Element uses itself to remove itself.
            - ex. `mainHeading.parentElement.removeChild(mainHeading);`
        - Other useful properties
            - `.firstChild`
                - Caution: might return whitespace if there is any instead of an HTML tag
            - `.firstElementChild`
                - Will return the first element
    - `<element>.remove();`
        - Is called directly on the element to be removed. Simple.
- Style Page Content
    - `.style.<prop>`
        - Modifies the element's style attribute which has the mtypeost CSS specificity
            - Can only modify one CSS style at a time.
            - CSS properties are written in camel case, not standard CSS
        - example:  `mainHeading.style.backgroundColor = 'orange';`
    - `style.cssText`
        - Can do multiple styles at once. Uses actual CSS names for styles
        - Put in a semicolon separated list.
        - Overwrites any pre-existing styles in the style attribute
        - example:  `mainHeading.style.cssText = 'color: blue; background-color: orange;`
    - `.setAttribute()
        - example: `mainHeading.setAttribute('style', 'color: blue; background-color: orange; 
        font-size: 3.5em;');
        - Can use this for any atribute of an element
    - `.className`
        - Returns a string of all of the element's classes
            - String is a space separated list. use the `.split(' ');` method to build
            an array you can use
        - Can set class or classes as well though it will replace any pre-existing classes
    - `classList`
        - Returns a DOMTokenList (which is much nicer to work with)
        - Popular properties
            - `.add()` to add a class to the list
            - `.remove()` to remove a class from the list
            - `.toggle()` to add the class if it doesn't exist or remove it if it does
            - `.contains()` returns a boolean based on if the class exists or not


#Working with Browser Events
- Seeing an event
    - Chrome browser has a function: `monitorEvents(element_to_be_monitored)`
        - `monitorEvents(element_to_be_monitored)` will stop monitoring
        - For dev/testing purposes only. Should not be in production code
    - "Event Target Interface" > "Node Interface" > "Element Interface"
        - Every other interface inherits from "Event Target Interface" and therfore contains
        its properties nd methods.
        - Both the document object and _any DOM element_ can be an event target.
- Respond to Events
    - `.addEventListener()`
        - `<event-target>.addEventListener(<event-to-listen-for>, 
        <function-to-run-when-an-event-happens>);`
    - an event listener needs three things:
        1. an event target - this is called the "target"
        2. the tpe of event to listen for - this is called the "type"
            - Could be a clicks, double click, pressing a key on the keyboard, scrolling,
            submitting a form, many more!
        3. a function to run when the event occurs - this is called the "listener"
    - list of Events
        - https://developer.mozilla.org/en-US/docs/Web/Events
- Remove an Event listener
    - `.removeEventListener()`
        - `<event-target>.removeEventListener(<event-to-listen-for>, 
        <function-to-remove>);`
    - an event listener needs three things:
        1. an event target - this is called the "target"
        2. the tpe of event to listen for - this is called the "type"
            - Could be a clicks, double click, pressing a key on the keyboard, scrolling,
            submitting a form, many more!
        3. a function to run when the event occurs - this is called the "listener"
    - NOTE: the function specified in the `.removeEventListener()` must be the extact
    same function (in the Javascript equality sense) and not just an identical looking 
    function.
    - For the `.removeEventListener()` to work, it must have the same target, type, and
    listener of the `.addEventListener` it is trying to remove.
- Lifecycle of an event
    - 3 Phases
        1. The "capturing" phase
        2. The "at target" phase
        3. And the "bubbling" phase
    - It follows the above order
    - The "capturing" phase happens at the top (<HTML> element) and works its way down
    to the target. "Capturing" lets the parent intercept an event before it reaches a child.
    - The "bubbling" phase happens when an event arrives at its target and doesn't have a 
    listener. 
        - By default if you click a child item and a handler doesn't intercept the click, 
        the event will "bubble" upward to the parent and keep bubbling unitl something 
        handles it or it hits the document.
        - You can pass a third argument `true` to the `.addEventListener()` function to
        invoke the listener earlier, during the "capturing" phase.
    - The event object
        - Just a regular javascript object that includes a ton of information about the
        event itself.
        - Add an event parameter to the event listener to store the event object
            - `document.addEventListener('click', function(event) {
                console.log('The document was clicked');
            });`
            - An 'event' is an 'evt' is an 'e'
                - The function paramter is just a regular variable so call it what you like.
        - Prevent default
            - One handy use of the capturing the event object is that you can prevent the 
            default action from happening (so click on a link and _not_ open a page, validate
            a form before submitting it, etc.) by calling the `.preventDefault()` method.
            - `target.addEventListener('click', function (event) {
                event.preventDefault()
            })`
        - `.target`
            - property of the event object which gives us direct access to the element that
            was clicked.
            - Provides access to `evt.target.textContent` or whatever other properties we 
            want to modify.
            - Allows a single event listener on parent to monitor all child elements
            - To make sure the child is the one we want try:
                `if (evt.target.nodeName === 'ELEMENT_NAME') { whatevs }`
                - `.nodeName` returns a all caps string.
- Know when the DOM is ready
    - The DOM is built incrementally and sequentially!
        - There is the potential for JS to run before the HTML elements are created
    - Solution 1 - Place JS bottom of file.
    - Solution 2 - Browser Events
        - When the DOM has been fully loaded, the browser will fire a `DOMContentLoaded`
        event
        ` document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Loaded - do the thing')
        });
        - However, as the wrapper function adds more code, generally better to just put
        JS at end of HTML.
            - Exception is if you really need your JS to run before the rest of the JS.


#Performance
- Add Page Content Efficiently
    - Testing code performance
        - `performance.now()`
            - Returns an extremely accurate (to 5 microsends) timestamp.
            - Use to get an initial timestamp, then the code in question, then a final 
            timestamp. Subtract the two.
    - Appending to the page takes time. Appending to parent elements that takes less time.
        - Better to append a parent element with 200 children than to directly append those
        children 200 times to the document.body element.
            - Due to the browser needing the reflow and repaint the screen.
    - `.createDocumentFragment()`
        - lightweight version of the document structure. Changes made to the document 
        fragment don't affect the document, cause reflow, or incur and performance impact
        that can occur when changes are made.
        - `const fragment = document.createDocumentFragment()`
- Reflow and Repaint
    - Reflow - is the process of the browser laying out the page. 
        - Happens every time the layout is changed.
        - Fairly expensive (slow) process
    - Repaint - happens after reflow as the browser draws the new layout to the screen.
        - Fairly quick but still try to minimize
        - Hiding elements would cause a repaint but not a reflow
    - Ex. if you add a CSS class to an element, the browser often recalculates the layout
    of the entire page -- triggering a reflow and repaint.
    - Hide/Change/Show
        - Good pattern to use to minimize reflows if changes are relatively contained
        - "Change" could mean add/delete/or change
- The Call Stack
    - a list of functions that are running. When a function is invoked, it is added to the 
    list. When all of the code in the function is executed, it is removed from the stack.
    - functions run to completion
    - Javascript is single-threaded
- The Event Loop
    - JS Concurrency Model:
        - (1) If some JS is running, let it run until it is finished ("run-to-completion")
        - (2) If no JS is running, run any pending event handlers.
    - Event loop: pick up the next event, run its handler, and repeat
    - 3 parts around event loop
        - (1) the Call Stack
        - (2) Web API's/the browser
        - (3) an Event Queue
    - Web API's/browser (aka asynchronous things)
        ex. `.addEventListener()` or `setTimeout()`
    - Asynchronous code is moved from the call stack to the web api/browser. When it is ready
    to be executed, it is moved to the event queue where it waits until the call stack is 
    empty. Then it is moved to the call stack and gets executed.
- `setTimeout()`
    - takes (1) a function to run at some later time (2) the number of milliseconds the code
    should wait before running the function.
    - ex:
        `setTimeout(function sayHi() {
            console.log('Howdy');
        }, 1000);`
    - `setTimeout()` with a Delay of 0
        - Can potentially convert long running code to one that's broken up for user
        interaction.
        - Gives user interaction a chance to trigger events since long running code 
        gets rotued through the event queue.

# Writing Test Suites with Jasmine
- Syntax
    - `describe` - used to identify a suite - a group of related specs
    - `it` used to identify a specification (aka "spec") - a container for a test
        - If any of the `expect` functons within a spec fail - the spec fails
    - `expect` - used to launch a test 
        - `expect(actual(test_parameters)).matcher(expected_vaues)`
    - `beforeEach` - function defined once that will run before each test.
    - Example:
            describe("Player", function() {
                var player;
                var song;

                beforeEach(function() {
                    player = new Player();
                    song = new Song();
                });

                it("should be able to play a Song", function() {
                    player.play(song);
                    expect(player.currentlyPlayingSong).toEqual(song);

                    //demonstrates use of custom matcher
                    expect(player).toBePlaying(song);
            });

- Red, Green, Refactor cycle
    - Write your spec. Fix each failure. Refactor.

## Promises
# Creating Promises
- Promises are the best way to handle asynchronous code
    - They are try catch wrapper around code that will finish at a variable time.
- Promise terms
    - Fulfilled (aka resolved) - it worked.
    - Rejected - It didn't work.
    - Pending - Still waiting...
    - Settled - Something happened
        - Can only settle once
- Time between creating and resolving promise can block main JS thread
- Syntax
    - Exmample:
        new Promise(function(resolve, reject){
            var value = doSomething();
            if (thingWorked) {
                resolve(value);
            } else if (somethingWentWrong) {
                reject();
            }
        }).then(function(value){
            // success!
            return nextTheing(value);
        }).catch(rejectFunction);

    - The value at resolve is passed to the `.then()` function if it resolves. Values to
    reject passes to the next `.catch()`. 
        - If nothing is passed to `reject()` then it is undefined and still gets evaluated 
        by `.catch()`. JS errors also get handled by `.catch()`.
- `fetch`
    - Easier to use than XHR




# React
## Why React
- "Compositional model, declarative nature, the way data flows through a component, 
and really just javascript"
    - Composition - to combine simple functions to build more complicated ones
    - Reach functions take in some arguments and return some ui
    - Each function should only do one thing.
    - React relies heavily on composition.
- React is declarative (not imperative)
- Unidirectional data flow (cf. data binding in Angular or Ember)
    - Flows from parent to child.
    - Child components can send updates to parent component (where parent performs
    actual change).
- "React is just javascript" - if you already feel comfortable with JavaScript, you'll
quickly feel comfortable with React.
- Array's `.map()` method
    - Get's called on an existing array and returns a new array based on what's 
    returned from the function that's passed as an argument.
    - Example:
        const names = ['Michael', 'Ryan', 'Tyler'];
        const namesLength = names.map( name => name.length );

    - Explanation:
        - The arrow function that's passed to `.map() gets called for each item in
        `names` array. The arrow function receives the first name in the array, 
        stores it in the `name` variable and returns its length. Then it does that again
        for the two remaining names.
        - `.map()` returns a new array with the values that are returned from the arrow
        function so `nameLengths` will be a new array `[7, 4, 5]`.
        - `.map()` returns a new array, it does not modify the original array.
- Array's `.filter()` method
    - Similar to `.map()`
        - Called on an array, takes a function as an argument, returns a new array
    - Difference is that function passes to `.filter()` is used as a test and only items
    in the array that pass the test are included in the new array.
    - Example:
        const names = ['Michael', 'Ryan', 'Tyler'];
        const shortNames = names.filter( name => name.length < 5 );
    
    - Explanation:
        - `shortNames` will be a new array with just `['Ryan']`.
        - First item is stored in the `name` variable. Then the test is performed.
        This is what's doing the actual filtering.
        - If it's 5 or greater, then it's skipped (and not included in the new array)
        - If is less than 5, then the function returns true and the name is included in 
        the array.
- Can chain `.map()` and `.filter()` together
    - Best to run `.filter()` first to reduce items for `.map()`

## Rendering UI with React
- React uses JavaSccript objects to build UI (not actual DOM elements)
- `.createElement()`
    - `React.createElement( /* type aka tag name */, /* props */, /* content */ )`
        - type = HTML element or React Component
        - props = either null or an object
        - content = null, string, React Element, or React Component
        - Using arrays as content
            - React would like to a unique key for the prop in that case
            - Can pass index using `.map()` and specifying index in the callback then use
            `{ key: index}` in the "props" part of `React.createElement()` 
    - In React deciding what to render is completely decoupled from actually rendering it.
    - `ReactDOM.render()` to render in the browser
    - Needs to hook into the DOM. Default is element with id='root'
-JSX
    - Is a syntax extension to `.createElement()` that lets us write JavaScript code that looks
    a little more like HTML.
    - Use braces {} to get React to evaluate JavaScript insideof a JSX statement
    - For the key prop error, add a `key = {}` within the bracks of the JSX.
    - Must only return a single element (can have multiple cildren though).
    - Needs to be transpiled into regular JS before reaching the browser.
        - Typically Babel is used to transpile. And Babel is usually run through a build tool
        like Webpack.
- Can write in `debugger` in pause script execution at the point. 
- Components
    - Can group many elements together and use them as if they were one element.
    - `render()` is the only method absolutely required in any component class.
        - Things will break without it.
    - Example:
        class Class_Name extends React.Component {
        // ...
        }
    - In other word, we are defining a component that's really just a JS class that
    inherits from `React.Component`
        - May also see:
            class Class_Name extends Component {
            // ...
            }
        - Functionally the same but make usre that the module import matches accordingly:
        import React, { Component } from 'react';
- React without a build step
    - https://shinglyu.github.io/web/2018/02/08/minimal-react-js-without-a-build-step-updated.html

## Composing with Compnents
- Main unit of encapsulation
    - React encourages building websites using composition instead of inheritance.


# State Management
## Introduction
- Props - allow you to pass data ubti your components.
- Functional Components - an alternative way to create components.
- Controlled Components - allow you to hook up the forms in yor application to
your component state.
## Pass Data With Props
- `prop` - any input you pass to a component.
- Treat just like an HTML attribute.
- Access from inside component using:
    `this.props.whatever_attribute_name`
## Functional Components
- If all your component has is a render memethod, can just create it as a 
function.
    - aka "Stateless Functional Component"
    - Takes in props, returns description of UI.
        - Don't need to create it as a class. Create is as a normal function.
    - No `this` keyword. Access props with `props.whatever_you_want` instead of 
    `this.props.whatever_you_want`
        - Make sure you pass `props` to the function though.
## Add State To A Component
- `props` refers to "read-only" or immutable data.
- `state` represent mutable data.
- To add stat, above the `render()` part add:
    state = {
        whatever: 'whatevs'
    }
- Can access what is the `state` object with `{this.state.whatever}`
- Avoid initializing `state` with `props` 
    - This is an error-prone anti-patten since `state` will only be initalized
    with `props` when the component is first created.
- By having a component manage its own state, any time changes are made to that
state, React will automatically make the changes and update the page.
    - Called "reconciliation"
## Update State with `setState`
- Cannot just directly `this.state.whatever = newWhatevs`
- "Your UI is just a function of your state"
    - Beause once `state` changes, UI will update accordingly.
- Two ways to change state.
    - Pass in an object:
        this.setState({
            whatever: 'new whatevs'
        })
    - Pass in a function:
        this.setstate((prevState) => ({
            whatever: prevState.whatevs + 1
        }))